package netlib.net;import java.util.concurrent.BlockingQueue;import java.util.concurrent.Executor;import java.util.concurrent.LinkedBlockingDeque;import java.util.concurrent.ThreadFactory;import java.util.concurrent.ThreadPoolExecutor;import java.util.concurrent.TimeUnit;import android.annotation.SuppressLint;import android.util.Log;// 线程池的实现方式@SuppressLint("NewApi")public class MyThreadPool {    private final static int POOL_SIZE = 6;// 线程池的大小最好设置成为CUP核数的2N    private final static int MAX_POOL_SIZE = 8;// 设置线程池的最大线程数    private final static int KEEP_ALIVE_TIME = 2;// 设置线程的存活时间    private final Executor mExecutor;    BlockingQueue<Runnable> workQueue;    private int priority;        public MyThreadPool(int priority) {    		this.priority =priority;        // 创建线程池工厂        ThreadFactory factory = new PriorityThreadFactory("thread-pool", priority);        // 创建工作队列        workQueue = new LinkedBlockingDeque<Runnable>();        mExecutor = new ThreadPoolExecutor(POOL_SIZE, MAX_POOL_SIZE, KEEP_ALIVE_TIME, TimeUnit.SECONDS, workQueue, factory);    }    // 在线程池中执行线程    public void submit(Thread command){        mExecutor.execute(command);        int threadSize = workQueue.size();          Log.e("R:",this.priority+":线程队列大小为-->"+threadSize);      }}