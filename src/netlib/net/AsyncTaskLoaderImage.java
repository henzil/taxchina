package netlib.net;import java.io.File;import java.math.BigInteger;import java.security.MessageDigest;import java.security.NoSuchAlgorithmException;import java.util.ArrayList;import java.util.Collection;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Set;import netlib.util.ImageUtil;import netlib.util.LibIOUtil;import netlib.util.PhoneUtil;import android.content.Context;import android.graphics.Bitmap;import android.graphics.Bitmap.Config;import android.graphics.Canvas;import android.graphics.Paint;import android.graphics.PorterDuff.Mode;import android.graphics.PorterDuffXfermode;import android.graphics.Rect;import android.graphics.RectF;import android.support.v4.util.LruCache;import android.text.TextUtils;import android.util.Log;import android.view.ViewTreeObserver;import android.widget.ImageView;/** * @author henzil * @version create time:2013-7-28_下午2:03:54 * @Description 异步获取图片下载类 */public class AsyncTaskLoaderImage {	private final String MY_TAG = "AsyncTaskLoaderImage";	private static AsyncTaskLoaderImage asyncTaskLoadImage = null;	private MyThreadPool originalThreadPool;// =											// Executors.newFixedThreadPool(4);	private Context context;	private final Object _lock = new Object();	public LruCache<String, Bitmap> _cache;	private HashMap<String, List<BitmapImageCallback>> _callbacks;	private HashMap<String, LoaderImageThread> threads;	private HashMap<String, String> urlMap;	private String imagePath = null;	public static final int DEFAULT_MAX_WIDTH = 320;	public static final int DEFAULT_MAX_HEIGHT = 480;	public static interface BitmapImageCallback {		void onImageLoaded(Bitmap bitmap, String url);	}	private AsyncTaskLoaderImage(Context context) {		originalThreadPool = new MyThreadPool(11);		final int cacheSize = PhoneUtil.getCacheSize(context);		_cache = new LruCache<String, Bitmap>(cacheSize) {			@Override			protected int sizeOf(String key, Bitmap bitmap) {				return ImageUtil.getBitmapByteCount(bitmap);			}		};		this.context = context;		_callbacks = new HashMap<String, List<BitmapImageCallback>>();		threads = new HashMap<String, AsyncTaskLoaderImage.LoaderImageThread>();		imagePath = LibIOUtil.getImagePath(context);	}	public synchronized static AsyncTaskLoaderImage getInstance(Context context) {		if (asyncTaskLoadImage == null) {			asyncTaskLoadImage = new AsyncTaskLoaderImage(context);		}		return asyncTaskLoadImage;	}	// 对图片名字md5 加密	public static String getHash(String url) {		try {			MessageDigest digest = MessageDigest.getInstance("MD5");			digest.update(url.getBytes());			return new BigInteger(digest.digest()).toString(16);		} catch (NoSuchAlgorithmException ex) {			return url;		}	}	public void addBitmapToMemoryCache(String key, Bitmap bitmap) {		if (bitmap != null && !bitmap.isRecycled()) {			_cache.put(key, bitmap);		}	}	private Bitmap getbitmapFromCache(String key) {		Bitmap b = null;		synchronized (_lock) {			b = _cache.get(key);			if (b != null) {				if (b.isRecycled()) {					_cache.remove(key);					b = null;				}			}		}		return b;	}	public Bitmap getbitmap(String key) {		Bitmap b = null;		synchronized (_lock) {			b = _cache.get(key);			if (b != null) {				if (b.isRecycled()) {					_cache.remove(key);					b = null;				}			}		}		return b;	}	private Bitmap loadSync(String TAG, String url, String hash, int width, int height, LoaderImageThread thread) {		Bitmap b = null;		try {			Log.i(MY_TAG, "url=" + url);			b = getbitmapFromCache(TAG + hash);			File f;			if (imagePath == null)				f = new File(context.getCacheDir(), hash);			else				f = new File(imagePath + hash);			if (b == null) {				if (f.exists()) {					if (urlMap.containsKey(url) && urlMap.get(url).equals(f.length())) {						b = getBitmap(f.getAbsolutePath(), width, height);						if (b == null) {							f.delete();						}					}				}				if (!f.exists() || (urlMap.containsKey(url) && !urlMap.get(url).equals(f.length()))) {					long fileLength = HttpClientUtil.downloadFile(url, f, context);					urlMap.put(url, fileLength + "");				}				if (thread == null || thread.isInterrupted()) {					return null;				}				if (f.exists() && b == null) {					b = getBitmap(f.getAbsolutePath(), width, height);					if (b == null) {						f.delete();					}				}				synchronized (_lock) {					addBitmapToMemoryCache(TAG + hash, b);				}			}		} catch (Exception ex) {			ex.printStackTrace();		}		return b;	}	/**	 * 	 * @param TAG	 *            谁加载图片	 * @param url	 *            加载哪张图片	 * @param callback	 *            返回什么数据	 */	public void loadAsync(String TAG, final String urlImage, BitmapImageCallback callback) {		urlMap = new HashMap<String, String>();		// final String		// url=urlImage+"&type="+PhoneUtil.getDisplayWidth(context)+"Id";		final String url = urlImage;		Log.v("tag", "url" + url);		if (url == null || url.equals("")) {			return;		}		// 对图片名字md5加密		final String hash = getHash(url);		Bitmap b = getbitmapFromCache(TAG + hash);		if (b != null && !b.isRecycled()) {			callback.onImageLoaded(b, url);			return;		}		synchronized (_lock) {			List<BitmapImageCallback> callbacks = _callbacks.get(TAG + hash);			if (callbacks != null) {				if (callback != null) {					callbacks.add(callback);				}				return;			}			callbacks = new ArrayList<BitmapImageCallback>();			if (callback != null) {				callbacks.add(callback);			}			_callbacks.put(TAG + hash, callbacks);		}		LoaderImageThread loaderImageThread = new LoaderImageThread(TAG, url, hash);		if (!threads.containsKey(TAG + hash)) {			threads.put(TAG + hash, loaderImageThread);			originalThreadPool.submit(threads.get(TAG + hash));			Log.d("IMAGEURL", "URL:" + TAG + hash);		}	}	/**	 * 	 * @param TAG	 *            谁加载图片	 * @param url	 *            加载哪张图片	 * @param imageView	 *            哪个imageview，得到宽高。	 * @param callback	 *            返回什么数据	 */	public void loadAsync(final String TAG, String urlImage, final ImageView imageView, BitmapImageCallback callback) {		final String url = urlImage;		urlMap = new HashMap<String, String>();		if (url == null || url.equals("")) {			return;		}		// 对图片名字md5加密		final String hash = getHash(url);		Bitmap b = getbitmapFromCache(TAG + hash);		if (b != null && !b.isRecycled()) {			callback.onImageLoaded(b, url);			return;		}		synchronized (_lock) {			List<BitmapImageCallback> callbacks = _callbacks.get(TAG + hash);			if (callbacks != null) {				if (callback != null) {					callbacks.add(callback);				}				return;			}			callbacks = new ArrayList<BitmapImageCallback>();			if (callback != null) {				callbacks.add(callback);			}			_callbacks.put(TAG + hash, callbacks);		}		if (imageView.getWidth() > 0) {			LoaderImageThread loaderImageThread = new LoaderImageThread(TAG, url, hash, imageView.getWidth(),					imageView.getHeight());			if (!threads.containsKey(TAG + hash)) {				threads.put(TAG + hash, loaderImageThread);				originalThreadPool.submit(threads.get(TAG + hash));				Log.d("IMAGEURL", "URL:" + TAG + hash);			}		} else {			imageView.getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {				@Override				public void onGlobalLayout() {					LoaderImageThread loaderImageThread = new LoaderImageThread(TAG, url, hash, imageView.getWidth(),							imageView.getHeight());					if (!threads.containsKey(TAG + hash)) {						threads.put(TAG + hash, loaderImageThread);						originalThreadPool.submit(loaderImageThread);						Log.d("IMAGEURL", "URL:" + TAG + hash);					}					imageView.getViewTreeObserver().removeGlobalOnLayoutListener(this);				}			});		}	}	private Bitmap getBitmap(String fileName, int width, int height) {		return ImageUtil.getBitmapFromMedia(context, fileName, width, height);	}	public Bitmap toRoundCorner(Bitmap bitmap, int width, int height) {		if (bitmap != null) {			Bitmap output = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Config.ARGB_8888);			Canvas canvas = new Canvas(output);			Paint paint = new Paint();			Log.e("tag", "bitmap.getWidth() = " + bitmap.getWidth());			Log.e("tag", "bitmap.getHeight() = " + bitmap.getHeight());			Rect rect = new Rect(0, 0, bitmap.getWidth(), bitmap.getHeight());			RectF rectF = new RectF(rect);			float roundPx = bitmap.getWidth();			float roundPy = bitmap.getHeight();			if (width == -1) {				roundPx = bitmap.getWidth();			} else {				roundPx = width;			}			if (height == -1) {				roundPy = bitmap.getHeight();			} else {				roundPy = height;			}			paint.setAntiAlias(true);			canvas.drawARGB(0, 0, 0, 0);			canvas.drawRoundRect(rectF, roundPx, roundPy, paint);			paint.setXfermode(new PorterDuffXfermode(Mode.SRC_IN));			canvas.drawBitmap(bitmap, rect, rect, paint);			return output;		}		return null;	}	private class LoaderImageThread extends Thread {		private boolean isInterrupted;		private String url;		private String hash;		private String TAG;		private int width = DEFAULT_MAX_WIDTH;		private int height = DEFAULT_MAX_HEIGHT;		public LoaderImageThread(String TAG, String url, String hash) {			super();			this.url = url;			this.hash = hash;			this.TAG = TAG;		}		public LoaderImageThread(String TAG, String url, String hash, int width, int height) {			super();			this.url = url;			this.hash = hash;			this.TAG = TAG;			this.width = width;			this.height = height;		}		public void setInterrupted(boolean isInterrupted) {			this.isInterrupted = isInterrupted;		}		public boolean isInterrupted() {			return isInterrupted;		}		@Override		public void run() {			try {				Bitmap d = loadSync(TAG, url, hash, width, height, this);				List<BitmapImageCallback> callbacks;				synchronized (_lock) {					callbacks = _callbacks.remove(TAG + hash);				}				for (BitmapImageCallback iter : callbacks) {					if (isInterrupted()) {						if (d != null && !d.isRecycled()) {							d.recycle();						}						d = null;						return;					}					iter.onImageLoaded(d, url);				}			} catch (Exception e) {				e.printStackTrace();			}		}	}	/**	 * 	 * @param TAG	 * @param urlStr	 * @Description 单个回收	 */	public void recycleBitmap(String TAG, String urlStr) {		if (TextUtils.isEmpty(urlStr)) {			return;		}		final String hash = getHash(urlStr);		Bitmap bitmap = _cache.remove(TAG + hash);		if (bitmap != null) {			if (!bitmap.isRecycled()) {				bitmap.recycle();				Log.i(MY_TAG, "recycleBitmap urlStr = " + urlStr + ", hitCount=" + _cache.hitCount()						+ ",evictionCount=" + _cache.evictionCount() + ",size=" + _cache.size());			}			bitmap = null;		}		LoaderImageThread loaderImageThread = threads.remove(TAG + hash);		if (loaderImageThread != null) {			loaderImageThread.setInterrupted(true);		}		List<BitmapImageCallback> list = _callbacks.remove(TAG + hash);		if (list != null) {			list.clear();			list = null;		}	}	/**	 * 	 * @param TAG	 * @param map	 * @Description 通过map回收	 */	public void recycleBitmaps(String TAG, Map<String, String> map) {		if (map == null) {			return;		}		Set<Map.Entry<String, String>> set = map.entrySet();		for (Iterator<Map.Entry<String, String>> it = set.iterator(); it.hasNext();) {			Map.Entry<String, String> entry = it.next();			recycleBitmap(TAG, entry.getKey());		}	}	/**	 * 	 * @param TAG	 * @param map	 * @Description 通过collection回收	 */	public void recycleBitmaps(String TAG, Collection<String> urlStrs) {		if (urlStrs != null && !urlStrs.isEmpty()) {			for (String imageUrl : urlStrs) {				recycleBitmap(TAG, imageUrl);			}		}	}	public void releaseMemory() {		threads.clear();		threads = null;		_callbacks.clear();		_callbacks = null;		_cache.evictAll();		_cache = null;	}	public static boolean clearCache(Context context) {		boolean isSucc = clearImg(context);		asyncTaskLoadImage = new AsyncTaskLoaderImage(context);		return isSucc;	}	public static boolean clearImg(Context context) {		String imagePath = LibIOUtil.getImagePath(context);		if (imagePath == null) {			imagePath = context.getCacheDir().getAbsolutePath();		}		if (LibIOUtil.isDirExist(imagePath)) {			return LibIOUtil.deleteFolder(new File(imagePath));		}		return true;	}}